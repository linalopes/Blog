<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hand-Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #ffffff; font-family: sans-serif; }

        /* UI removed - minimal interface */

        /* Loading & Status */
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            letter-spacing: 5px;
            animation: pulse 1.5s infinite;
            z-index: 5;
        }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        /* Hide the video element used for tracking */
        .input_video { display: none; }
    </style>
</head>
<body>

    <div id="loading">INITIALIZING CAMERA...</div>

    <div id="status">Waiting for hand detection...</div>

    <!-- Video Element for MediaPipe -->
    <video class="input_video"></video>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. CONFIGURATION & STATE ---
        const config = {
            particleCount: 15000,
            baseColor: new THREE.Color(0xff0055),
            handTension: 0.0, // 0 = closed, 1 = open
            handPresent: false,
            currentTemplate: 'fireworks' // Only fireworks mode
        };

        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        // Fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 3. PARTICLE SYSTEM ---

        // Generate a soft glow texture programmatically
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.particleCount * 3);
        const targetPositions = new Float32Array(config.particleCount * 3); // Where they want to go
        const velocities = new Float32Array(config.particleCount * 3); // Physics

        // Initialize arrays
        for (let i = 0; i < config.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 100;
            targetPositions[i] = positions[i];
            velocities[i] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: config.baseColor,
            size: 0.4,
            map: createParticleTexture(),
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. FIREWORKS TEMPLATE GENERATOR ---

        function updateTargets() {
            const count = config.particleCount;
            const targets = targetPositions;

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Fireworks: Sphere explosion pattern
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 20 * Math.cbrt(Math.random()); // Even volume distribution
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                targets[i3] = x;
                targets[i3 + 1] = y;
                targets[i3 + 2] = z;
            }
        }

        // Initialize with fireworks
        updateTargets();

        // --- 5. MEDIAPIPE HANDS SETUP ---
        const videoElement = document.getElementsByClassName('input_video')[0];

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                config.handPresent = true;
                document.getElementById('status').innerText = "Hand Detected";

                const landmarks = results.multiHandLandmarks[0];

                // Calculate "Openness"
                // Distance between wrist(0) and Middle Finger Tip(12)
                const wrist = landmarks[0];
                const tip = landmarks[12];

                // Simple distance heuristic in 2D normalized space
                const distance = Math.sqrt(
                    Math.pow(wrist.x - tip.x, 2) +
                    Math.pow(wrist.y - tip.y, 2)
                );

                // Map distance: roughly 0.1 (closed) to 0.4 (open)
                // We want 0 to 1 range
                let openness = (distance - 0.15) * 4;
                openness = Math.max(0, Math.min(1, openness));

                // Smooth interpolation for jitter reduction
                config.handTension += (openness - config.handTension) * 0.1;
            } else {
                config.handPresent = false;
                document.getElementById('status').innerText = "Waiting for hand...";
                // Default to open if no hand
                config.handTension += (1.0 - config.handTension) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraUtils.start();

        // --- 6. INTERACTION LOGIC ---
        // Color picker removed - using default pink color

        // --- 7. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Rotate entire system slowly
            particles.rotation.y = time * 0.1;

            const positionsArr = particles.geometry.attributes.position.array;

            // Physics Factors
            // If hand is closed (tension 0), we want implosion (scale down)
            // If hand is open (tension 1), we want target shape (scale normal)

            // Scale factor based on hand: 0.1 to 1.5
            const scaleTarget = 0.2 + (config.handTension * 1.3);

            // Expansion jitter for "Fireworks" feel when open
            const noise = 0.2;

            for (let i = 0; i < config.particleCount; i++) {
                const i3 = i * 3;

                // Current pos
                let px = positionsArr[i3];
                let py = positionsArr[i3+1];
                let pz = positionsArr[i3+2];

                // Target pos (base shape)
                let tx = targetPositions[i3] * scaleTarget;
                let ty = targetPositions[i3+1] * scaleTarget;
                let tz = targetPositions[i3+2] * scaleTarget;

                // Add noise/float
                tx += Math.sin(time * 2 + i) * noise;
                ty += Math.cos(time * 3 + i) * noise;

                // Physics: Ease towards target
                // If hand is closed (low tension), movement is fast/snap
                const speed = 3.0 * delta;

                px += (tx - px) * speed;
                py += (ty - py) * speed;
                pz += (tz - pz) * speed;

                positionsArr[i3] = px;
                positionsArr[i3+1] = py;
                positionsArr[i3+2] = pz;
            }

            particles.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
